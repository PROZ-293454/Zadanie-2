package model;

import static model.Ball.Color.*;
import static model.BoardModel.MY_COLOR;
import static model.BoardModel.tableOfMoves;
import static model.Move.*;
import static model.Orientation.HORIZONTAL;
import static model.State.CHOOSE_FIRST_BALL;
import static model.State.CHOOSE_MOVE;
import static model.State.CHOOSE_SECOND_BALL;

import java.util.List;

import javax.jms.JMSException;
import javax.jms.TextMessage;

import model.Ball.Color;
import view.Board;

public class BoardModel {

	public static final Color MY_COLOR = BLACK; // second player: WHITE
	public static final Move[] tableOfMoves = { E, SE, SW, W, NW, NE };

	private int myCounter;
	private int opponentCounter;
	private State state;

	public State getState() {
		return state;
	}

	/**
	 * Method is called, when user chose their first ball
	 * 
	 * @param ball - first chosen Ball
	 */
	public void chooseFirstBall(Ball ball) {

		chosenBalls.add(ball);
		state = CHOOSE_SECOND_BALL;
	}

	/**
	 * Method is called, when user chose their second ball Method calls for creating
	 * list of chosen balls
	 * 
	 * @param ball - second chosen Ball
	 * @return orientation of the line made by chosen balls
	 */
	public Orientation chooseSecondBall(Ball ball) {
		int x1 = chosenBalls.get(0).getPosX();
		int x2 = ball.getPosX();
		int y1 = chosenBalls.get(0).getPosY();
		int y2 = ball.getPosY();
		int dx = x2 - x1;
		int dy = y2 - y1;

		if (!chosenBalls.get(0).equals(ball)) {
			state = CHOOSE_MOVE;
			return chooseBalls(dx, dy, x1, y1);
		} else {
			state = CHOOSE_MOVE;
			return HORIZONTAL;
		}
	}

	public int numberOfChosenBalls() {
		return chosenBalls.size();
	}

	/**
	 * Method creates a table of moves (table of integers, each one is a number of
	 * free fields in every direction
	 * 
	 * @return a table of moves
	 */
	public int[] makeMovesTable(ListOfBalls myBallsList, ListOfBalls opponentBallsList) {
		int[] movesTable = { 0, 0, 0, 0, 0, 0 };

		for (Ball tmpBall : chosenBalls) {
			for (Move move : tableOfMoves) {
				if (myBallsList.getBall(tmpBall.getPosX() + move.dx(), tmpBall.getPosY() + move.dy()) == null
						&& opponentBallsList.getBall(tmpBall.getPosX() + move.dx(),
								tmpBall.getPosY() + move.dy()) == null)
					movesTable[move.id()]++;
			}
		}
		return movesTable;
	}

	/**
	 * Method is called, when user clicks on a button, which indicates the direction
	 * of a move
	 * 
	 * @param move        - chosen move direction
	 * @param orientation - orientation of a line of chosen balls
	 */
	private void moveChoiceClicked(Move move, Orientation orientation) {

		moveBalls(move, orientation); // moving balls on a board

		Messaging.sendQueueMessage(Messaging.makeMsgString(chosenBalls, opponentToMoveBalls, move));
		chosenBalls.removeAll(chosenBalls);
		opponentToMoveBalls.removeAll(opponentToMoveBalls);

	}

	/**
	 * Method sets a listener for a consumer, which receive a message from the
	 * server and then perform described action
	 */
	private void setConsumerListener() {
		Messaging.getJmsConsumer().setMessageListener(message -> {
			try {
				String msg = ((TextMessage) message).getText();
				Move move = Messaging.readFromMsgString(msg, myBoard.getMyBallsList(), myBoard.getOpponentBallsList());

				chosenBalls = Messaging.getChosenBalls();
				opponentToMoveBalls = Messaging.getOpponentToMoveBalls();
				moveBalls(move, null);
				chosenBalls.removeAll(chosenBalls);
				opponentToMoveBalls.removeAll(opponentToMoveBalls);
				state = CHOOSE_FIRST_BALL;
			} catch (JMSException e) {
				e.printStackTrace();
			}
		});
	}
	
	public Orientation chooseBalls(int dx, int dy, int x1, int y1, ListOfBalls myBallsList) {
		for (int i = 1;; i += 1) {
			Ball tmpBall = myBallsList.getBall(x1 + i * (int) Math.signum(dx), y1 + i * (int) Math.signum(dy));
			if (tmpBall != null) {
				chosenBalls.add(tmpBall);
			}
			if (i == Math.abs(dx))
				break;
			if (i > 10)
				break;
		}
		return Orientation.getOrientation(dx, dy);
	}
	
	/**
	 * Method moves balls on the board. Method calls Board class method to make a
	 * move.
	 * 
	 * @param move        - the direction of a move
	 * @param orientation - the orientation of a line of chosen balls
	 */
	public void removeOpponentToMoveBalls(Move move, Orientation orientation) {
		
		if (orientation != null) {
			Move[] movesAlongLine = orientation.possibleMoves();
			if (!((movesAlongLine[0].equals(move) || movesAlongLine[1].equals(move))
					&& tableOfMoves[move.id()].isPossible())) {
				opponentToMoveBalls.removeAll(opponentToMoveBalls);
			}
		}

	}


	private ListOfBalls chosenBalls;
	private ListOfBalls opponentToMoveBalls;

	public ListOfBalls getChosenBalls() {
		// TODO Auto-generated method stub
		return chosenBalls;
	}

	public ListOfBalls getOpponentToMoveBalls() {
		// TODO Auto-generated method stub
		return opponentToMoveBalls;
	}

	public String getAlertText() {
		if (myCounter >= 4) {
			return "WYGRA£EŒ";
		} else if (opponentCounter >= 4) {
			return "PRZEGRA£EŒ";
		}
		else return null;
	}
}
